![Workshop-logo](../IM/LOGO_new.png)
# Applications of Genomics in Wildlife Conservation

## Day 1 - Session 1 - Basic concepts of command line programming


### Part 1: The filesystem 
In this section we will revise basic commands to navigate filesystems and create a series of directories and sub-directories for a research project. Naming file and directory is more important than you may think; a clear and consistent structure will make your life way much easier when you’ll have to deal with complex projects and pipelines. Feel free to adjust and customize this template structure as you please but keep this criteria in mind.

We should start with creating a parent directory for our project. 
```sh
mkdir Project_BASH 
cd Project_BASH
```
The first command (`mkdir`) creates the required folder while the `cd` command is used to move from your home directory to the newly created one. Now we need to create one directory where we are going to store our scripts, one for the raw data, and finally one for our results:

```sh
mkdir Scripts; mkdir Raw_Data; mkdir Results
```
note the use of the semicolon (;) to separate different commands on the same line.
> `Hacker Tips`: never use white spaces when naming files or directories

Then, we need to create a separate directory for each stage of our pipeline/analysis. Because of my lack of immagination, each directory will be termed as `Stage` and we are going to number them sequentially but I would encourage you to use a better naming
convention when it comes to your research. Given that typing the same command over and over is tedious, we are going to use one of the basics building blocks of any programming language: a loop.  

```sh
for i in $(seq 3)
do
mkdir Stage_$i
done
```
Let's unpack this programming structure:

The reserved word `for` is what signals the shell that the following commands need to be repeated.

The letter `i` is our iterator, the loop will stop when this variable has taken all the values in the array generated by the command `seq`. As you have probably figured out already, `seq 3` will generate a sequence of integers from 1 to 3 (included).  

In order to make this sequence available to the for loop, so that the machine will no when to stop, we use the bash syntax `$(command)` which roughly speaking means "insert here the output of the command in brackets". 

We then used the iterator (i) to name our directories. Because at each iteration i is going to assume a different value, we used the standard notation for variables in our mkdir command: $i.

Now let's look at what we have done: to list the content of a directory use the command `ls`.

For the sake of reproducibility, it is always a good idea to keep track of everything we do. I recommend you always log your command to a file keeping a consitent naming convention. Here we are going to call our log files `What_I_did.txt` and in order to create such files we will use the command `touch`. 

Each of our `Stage` directories should contain at least three items:
- a What_I_Did.txt file.
- an Output sub-directory
- a sub-directory called Input

In principles, you could navigate to the each Stage directory using the `cd` command and create these objects manually but that involves a lot of typing. You should instead use a loop to avoid this tedious task. An efficient way to do this from a shell terminal requires to create a list of parent directories and then create the child directories only where we need them.
```sh
ls -d Stage* > dir_list.txt
```
Note the use of the `>`. This symbol in bash has a special meaning: redirect the output of the command that precedes it to a file.

Now that we have the list, we can easily implement another type of loop using the reserved word `while`:
```sh
while read -r line
do
touch $line/What_I_Did.txt
done < dir_list.txt
```
note again the use of the `$` sign in front of the word `line` which is the syntax for variables in bash. This is because at each iteration the content of the variable `line` will change while we go through the list of directories contained in the `dir_list.txt` file. the loop will end when the variable `$line` is empty i.e. when we reach the end of the file.

> `Exercise 1`
>
> use a similar while loop to create a sub-directory called `Output` inside each Stage dir

If your pipeline is run sequentially, the output of the first step will serve as input for the second step and so on and so forth. Therefore, the content of `Stage 1/Output` and `Stage 2/Input` will be exactly the same. Avoiding redundancies and data duplication is a good way of saving space on disk though, thus, we don’t want to copy all the files from one directory to another: we are going to create a symbolic link instead.
```sh
ln -s ~/Project_BASH/Raw_Data/ ~/Project_BASH/Stage_1/Input
```
The `ln` command stands for ”link” and it has this general syntax:
```sh
ln full/path/to/source full/path/to/destination/link_name
```
Here we have used the `-s` flag to specify a symbolic link between the `Raw_Data` directory and a new `Input` folder (link name) inside the `Stage_1 directory`. This means that the content of `Raw_Data` is now accessible from `Stage_1/Input`. Let’s double-check it:
```sh
touch Raw_Data/input_zero.txt
ls Stage_1
ls Stage_1/Input
ls Raw_Data
```
The first command is just to pupulate the `Raw_Data` folder with a file (`input_zero.txt`). By running the second command you should see that an Input folder has been created via the `ln` command. Now the Stage 1 directory contains all three elements required. The output of the third and fourth commands should be just `input_zero.txt`.

> `Exercise 2`
>
> Use the ln command to complete our file system structure by linking each Stage_{i}/Output to an Input folder inside the Stage_{i+1} directory. Note that in our example Stage 4 is actually termed Results.

> `Hacker Tips`: if you have made a mistake with links, do not panic. You can alwayse remove them with `rm` or with the unlink command.

Now that we have a good structure we can start populating our directories. Let's create some files in the `Project_BASH` directory.

```sh
for i in $(seq 3)
do
touch output_file_$1
done
```
Now we should move each of these file to the corresponding `Stage_{i}/Output` directory.

> Exercise 3
>
> Use a for foop to move each of the output_file_{i} ∀i ∈ {1, 2, 3}.
To do so, you should use the `mv` command which has the following syntax: `mv target_file_name path/to/destination`.

If you now run the `tree` command from the Project_BASH directory, you should get:
![Workshop-logo](../IM/bash_tree.png)


