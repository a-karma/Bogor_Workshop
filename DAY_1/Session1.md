![Workshop-logo](../IM/LOGO_new.png)
# Applications of Genomics in Wildlife Conservation

## Day 1 - Basics concepts of command line programming
This session is diveded into three parts


#### 1. The filesystem 
In this section we will revise basic commands to navigate filesystems and create a series of directories and sub-directories for a research project. Naming file and directory is more important than you may think; a clear and consistent structure will make your life way much easier when you’ll have to deal with complex projects and pipelines. Feel free to adjust and customize this template structure as you please but keep this criteria in mind.

We should start with creating a parent directory for our project. 
```sh
mkdir Project_BASH 
cd Project_BASH
```
The first command (`mkdir`) creates the required folder while the `cd` command is used to move from your home directory to the newly created one. Now we need to create one directory where we are going to store our scripts, one for the raw data, and finally one for our results:

```sh
mkdir Scripts; mkdir Raw_Data; mkdir Results
```
note the use of the semicolon (;) to separate different commands on the same line.
> `Hacker Tips`: never use white spaces when naming files or directories

Then, we need to create a separate directory for each stage of our pipeline/analysis. Because of my lack of immagination, each directory will be termed as `Stage` and we are going to number them sequentially but I would encourage you to use a better naming
convention when it comes to your research. Given that typing the same command over and over is tedious, we are going to use one of the basics building blocks of any programming language: a loop.  

```sh
for i in $(seq 3)
do
mkdir Stage_$i
done
```
Let's unpack this programming structure:

The reserved word `for` is what signals the shell that the following commands need to be repeated.

The letter `i` is our iterator, the loop will stop when this variable has taken all the values in the array generated by the command `seq`. As you have probably figured out already, `seq 3` will generate a sequence of integers from 1 to 3 (included).  

In order to make this sequence available to the for loop, so that the machine will no when to stop, we use the bash syntax `$(command)` which roughly speaking means "insert here the output of the command in brackets". 

We then used the iterator (i) to name our directories. Because at each iteration i is going to assume a different value, we used the standard notation for variables in our mkdir command: $i.

Now let's look at what we have done: to list the content of a directory use the command `ls`.

For the sake of reproducibility, it is always a good idea to keep track of everything we do. I recommend you always log your command to a file keeping a consitent naming convention. Here we are going to call our log files `What_I_did.txt` and in order to create such files we will use the command `touch`. 

Each of our `Stage` directories should contain at least three items:
- a What_I_Did.txt file.
- an Output sub-directory
- a sub-directory called Input

In principles, you could navigate to the each Stage directory using the `cd` command and create these objects manually but that involves a lot of typing. You should instead use a loop to avoid this tedious task. An efficient way to do this from a shell terminal requires to create a list of parent directories and then create the child directories only where we need them.
```sh
ls -d Stage* > dir_list.txt
```

Now that we have the list, we can easily implement another type of loop using the reserved word `while`:
```sh
while read -r line
do
touch $line/What_I_Did.txt
done < dir_list.txt
```
If your pipeline is run sequentially, the output of the first step will serve as input for the second step and so on and so forth. Therefore, the content of `Stage 1/Output` and `Stage 2/Input` will be exactly the same. Avoiding redundancies and data duplication is a good way of saving space on disk though, thus, we don’t want to copy all the files from one directory to another: we are going to create a symbolic link instead.




